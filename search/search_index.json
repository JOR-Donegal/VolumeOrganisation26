{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Introduction","text":"<p>Volume Organisation</p> <p>Only a generation ago, hard disks appeared as the miraculously fast and infinitely large solution to all storage problems. Little did we know\u2026..!</p> <p>The earliest problems we had related to the crude and limited early file systems we used. The restrictions on these file systems meant we had to partition disks into volumes suited to our requirements; break them up into different logical sections so it appeared that we had multiple physical disks. In these notes, we will look at the original way we did that (MBR) and the current method (GPT).</p> <p>As our storage needs grew, cases existed where we needed to aggregate small disks to create logical volumes larger than we could physically. This concept is the basis for many of the approaches we take in enterprise and data centre storage. Most operating systems include some sort of logical volume manager or LVM which allows us to abstract the old, crude, inflexible concepts of partitions into something more closely aligned with modern OS requirements.</p> <p>We need to understand the principles behind both approaches, where they are used and why.</p>"},{"location":"a/","title":"MBR","text":"<p>My first hard disk was a staggeringly big 32 megabytes, sometime around 1988, on an Amstrad 1512. At that stage, I could hack floppy discs and took great pleasure going into programmes with a hex editor, completely changing how they looked. But this first hard drive was too big to format like a floppy disk and for the first time, I has to figure out partitioning a disk.</p> <p>The partitioning scheme introduced in 1983 was called Master Boot Record or MBR. This allowed for up to four separate partitions, each independent and with its own file system. In MBR the first sector of the hard drive is no longer part of a file system, instead it contains meta-data describing the partition layout of the entire physical drive.</p> Fig 1. MBR, first sector. <p>The first 445 bytes of sector 1 contains bootstrap code. The term bootstrap means for a system to start itself up or \"pull itself up by its own bootstraps\". For the system to work, one of the partitions must be bootable, it must be able to load an operating system (OS). The boot loader determines which partition is to be booted from and then chain loads the volume boot record from that partition\u2019s sector 1. If the boot partition was FAT (explained in later notes!), the first three bytes are a jump command and the system would proceed to boot from this partition.</p> Fig 2. MBR, partitions. <p>MBR allowed for up to four separate partitions, each independent and with its own file system. </p> <p>To get by the limit of four partitions, the concept of the primary partition and the extended partition were implemented. All primary partitions are defined in sector one of the hard drive. If we define one partition as being an extended partition, we can put a partition table inside the partition and pretend it\u2019s a disk. If it\u2019s a disk we can create partitions inside of it and one of these could be an extended partition, which we could pretend was a disk\u2026.and so on ad infinitum, ad absurdum!</p> <p>If anyone has ever come up with a more inelegant way of fixing a problem, I have yet to find it. MBR was messy and limited. A maximum of 2<sup>32</sup> Logical Block Addresses (LBA) gave a maximum addressable space of 2<sup>32</sup> x 512 or 2TB.</p>"},{"location":"b/","title":"GPT","text":"<p>MBR is old and was written for the computers of another era. The problems of MBR were not readily resolvable and an entire new standard was developed.</p> <p>Global Unique Identifiers (GUID) are unique identifiers which are so large that a collision (two systems with the same GUID) is not feasible. GUIDs are typically 128 bits long and are represented by 32 hexadecimal characters. The GUID Partition Table (GPT) standard uses these identifiers and GPT is part of UEFI specification, which replaces the older BIOS used as the lowest software layer in PC computers.</p> <p>GPT is more suited to modern requirements.</p> <ul> <li>It can address 2<sup>64</sup> Logical Block Addresses (LBAs)</li> <li>It can accommodate up to 128 partitions with no extended partitions</li> <li>The GUIDs provide unique disk labelling</li> <li>It includes for meta-data backup and integrity checking</li> </ul> Fig 3. GPT overview. <p>To protect the disk, a legacy MBR header exists at LBA 0. This shows the whole disk as being a single partition of type 0xEE. Any operating system which cannot read GPT should just show the disk as being of an unrecognizable type and ignore it.</p> Fig 4. Protective MBR. <p>Logical Block Address (LBA) 1 contains the real header for the GPT disk.</p> Fig 5. GPT Header. <p>An 8 byte signature \u201cEFI PART\u201d marks the start of the header and basic meta data relating to the header itself follows.  The location of this header and the backup header are both defined. This will normally be the second sector of the disk (LBA 1) and the last. The start and end of the partitions is given. A 16 byte unique ID for the disk is specified.  The start of the partition table is stated, as are the number of entries and their size.</p> Fig 6. Start of header. <p>The partition table entries are 128 bytes long. Each type of partition has a GUID associated with it, this is the first 16 bytes. Each partition then has its own unique GUID. The start and end LBA of the partition is defined. 64 bits are available for attribute flags, many of these are as yet undefined. Finally 72 bytes are available for partition name; using UTF-16, this gives a 36 character name.</p>"},{"location":"c/","title":"Virtualizing Storage","text":"<p>Most operating system implement some form of logical volume manager to abstract the storage from the requirements of the operating system. A physical volume (PV) used to be a hard drive, but on a modern system it could be a partition, or it could be a concatenation of drives. It could also be presented as a logical unit number (LUN) of a remote storage array.</p> <p>The physical volume will probably store data in sectors but these sectors are normally too small for optimal usage by the operating system. Sectors will be aggregated into blocks and blocks might be aggregated into physical extents (PE), a contiguous area of storage.</p> <p>The PEs aggregate to form a volume group or VG. Volume groups can be resized dynamically by adding new PVs.</p> Fig 7. Extents. <p>The OS will be presented with logical extents (LEs). These may map directly to PEs or more complex arrangements may exist. For example, we sometimes mirror data to two disks for high availability. In this case, we might have a single LE map to two discrete PEs on separate PVs. Virtual partitions can be created from LEs called logical volumes or LVs.</p> <p>LVs can be expanded by adding new LEs to them.</p> <p>LVs can be moved from PV to PV as required.</p> Fig 8. Hierarchy. <p>Software RAID allows us to make some very beneficial use of this flexibility.</p>"},{"location":"d/","title":"Partition Alignment","text":"<p>As you create partitions, you will see that different utilities have different defaults. Some of this is very historical. Long ago, we needed to understand the actual geometry of hard disks and understand the cylinders, heads and sectors (CHS) we were using. In fact, we used to put this information into the BIOS so the system could correctly operate the hard drive. None of this has really been the case since CHS was abandoned in favour of logical block addressing (LBA) in the 1990s. The values in the ATA CHS registers have no connection to the underlying topology of a modern disk. Look up zoning, there are not a fixed number of sectors per track! Alignment to track/cylinder boundaries is not required but is still commonly enforced.</p> <p>All my old Linux examples had disk drives with 63 sectors per track and the Linux partition utility fdisk started the first partition on sector 63; track alignment. But this means all the old examples have partitions aligned to an odd number.</p> <p>From c. 2009 we moved from 512b to 4,096b sectors and the correct alignment for performance is a 4KB alignment, almost all block operations are in quanta of 4KB. Different authorities give figures for performance penalties should you get this wrong, but I have seen claims as much as x25.</p> <p>Most modern tools use a 1MB alignment and start at sector 2048 * 512 = 1,048,576, this also works fine with 4KB sectors as 256 * 4096 = 1,048,576.</p>"}]}